#2 Blame in Contracts
- restrict throw is not a possibe because the CB structure is already updated

- what happen if if i apply Ctor and Ctor
- double abstraction

var Plus = Contract.Constructor(function(typeOf) {
  return Contract.AFunction([typeOf,typeOf], typeOf);
}, 'PLUS'),

plus @ Plus


var Id = var Plus = Contract.Constructor(function(typeOf) {
  return Contract.AFunction([In('x')], Ouit('x'));
}, 'PLUS'),


\forall X. X->X

Contract.AFunction([In(x)], Out(x));



assert with X Constr
construct


-> case (context specific change of the contract)
(Num->Num) Num->Num \cap Str->Str .. ok
(Num->Num \cap Str->Str) Num->Num .. ? call with 1 || call with "1"
-> subset of ?

Contract.Forall([X,Y,Z], ???);

[X,Y,Z] implements a new stack frame


Contract.AFunction([In(X)], Out(x));


var x = Contract.Variable(); // make id like sandxoc $123


Contact.Forall([X,Y])
Contract.AFunction([In(X),In(Y)], Contract.AObject([x:Out(X),y:Out(Y)]))

Contract.Forall(  function() {
  return Contract.AFunction([In(X)], Out(x));
});



// storyline

var Id = Contract.Constructor(function(X) {
  return Contract.AFunction([X],X);
}, "Id");

// normal abstracttion, X and X are the same contract


var Id = Contract.Constructor(function(X) {
  return Contract.AFunction([Contract.In(X)],Contract.Out(X));
}, "Id");

X has to be an identifier

// problem 
return Contract.AFunction([Contract.In(X)],Contract.Out(Y));
alleine sagt nicht ueber die Spezifikation von Y aus



Abs X,Y. Contract.AFunction([X], Y);
--->
function(X, Y) {
  return Contract.AFunction([X], Y);
}

------------------------------------

Forall X,Y. Contract.AFunction([X,Y], X);
--->
function(X, Y) {
  return Contract.AFunction([In(X), In(Y)], Out(Y));
}

Forall([X,Y], Constructor);


i brauch die variable garnicht
die for all abstracvtions sagt mir welche variablen durhc proioxies ersetyt werden, und 
bzw jede varibale / arguments wird duch einen neuen proxy erstestz

ud anstatt der werte wird dann der assiziierte proxy vernwedet ?



Contract.Forall(Contract.Constructor(
  function(X, Y) {
    return Contract.AFunction([In(X), In(Y)], Out(Y));
  }
));

--> arguments wird n proxy der nur gewrappte argumente zurueck gibt/ ber immer den gleichen 
--> teste how many access occurs

--> ? wi speichern egal, bekomme ne fresh ID

