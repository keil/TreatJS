





- need a global membrane that prevents the global objects from modifications, but allows applications


Config: globalPathTrought



- Constructor wrapped in a prozy tu use id with an direct application.

- Abstraction should also be a contract

- strict mode for objects




Indy/Pick/Lax
=============

- It is required to bind the context in the assertion, rather than only using the stack. 

 The stack would als guarantee INDY semantics, but it is not able to handle assignments correclty Thus we must bind the current context.






Increase Performance by reducing callback graphs
================================================

- use constraints/callback only when unrolling intersection and union.
- than, all sub contract report to the left or right side of an combinations.
- but, this may require the four valued login when implementing the constrains. Waht happens id the output of one side flips or subject/context are both false. Compare this with the current output.





#2 Blame in Contracts
- restrict throw is not a possibe because the CB structure is already updated

- what happen if if i apply Ctor and Ctor
- double abstraction

var Plus = Contract.Constructor(function(typeOf) {
  return Contract.AFunction([typeOf,typeOf], typeOf);
}, 'PLUS'),

plus @ Plus


var Id = var Plus = Contract.Constructor(function(typeOf) {
  return Contract.AFunction([In('x')], Ouit('x'));
}, 'PLUS'),


\forall X. X->X

Contract.AFunction([In(x)], Out(x));



assert with X Constr
construct


-> case (context specific change of the contract)
(Num->Num) Num->Num \cap Str->Str .. ok
(Num->Num \cap Str->Str) Num->Num .. ? call with 1 || call with "1"
-> subset of ?


